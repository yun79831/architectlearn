# architectlearn 架构学习之路

##设计模式
###[单例模式]()
    * 饿汉模式
    * 懒汉模式
    * 登记式
    * 枚举式
    * 序列化

###[原型模式]() 
    * 浅复制
    * 深复制

###[工厂模式]() 
      * 简单工厂
      * 工厂方法
      * 抽象工厂
###[策略模式]() 
      * 各个策略有共同的基类,具体使用中new不同的策略
    
###[适配器模式]() 

        涉及的角色　
            目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。
            源(Adapee)角色：现在需要适配的接口。
            适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口              

        * 类的适配器模式
            使用对象继承的方式
        * 对象的适配器模式(建议)
            对于对象适配器，需要额外的引用来间接得到Adaptee。        
            建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承
        
        
###[装饰器模式]() 

        装饰模式            增强功能 不改变接口
        半透明装饰模式     增强功能,改变接口
        适配器模式         改变接口,不改变功能?


            =====================================================================
            装饰器模式                         |   适配器模式
            -----------------------------------+---------------------------------
            是一种非常特别的适配器模式         |  可以不保留层级关系
            -----------------------------------+---------------------------------
            装饰者和被装饰者都要实现同一个接口 |  适配者和被适配者没有必然的层级联系
            主要目的是为了扩展，依旧保留OOP关系|  通常采用代理或者继承形式进行包装
            -----------------------------------+----------------------------------
            满足is-a的关系                     |   满足has-a
            -----------------------------------+----------------------------------
            注重的是覆盖、扩展                 |   注重兼容、转换
            -----------------------------------+----------------------------------
            
###[委派模式]() 
###[观者模式]() 
观察者模式的定义：
　　在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。
大白话：
　　其实就是发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。
抽象被观察者角色：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。
具体被观察者角色：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。
抽象观察者角色：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。
具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。

###[模板模式]()
###[代理模式]()